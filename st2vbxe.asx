; Show Atari ST graphics file in the DEGAS format:
; *.PI1 = 320x200, 16 colors from 512
; *.PI2 = 640x200, 4 colors from 512
; Filename is hard-coded, I'm too lazy to code a file picker or command line parsing. ;)
; I mean, that's an exercise for the reader!

; It's not that VBXE has as good graphics as ST. It has better:
; 320x240, 256 colors from 2097152
; 640x240, 16 colors from 2097152
; ST high resolution, that is 640x400 black-and-white, should also be doable
; using the interlace trick revealed in 2009 by Rybags.
; That's another exercise for you!

; "THE BEER-WARE LICENSE" (Revision 42):
; Piotr Fusik <fox@scene.pl> wrote this file.
; As long as you retain this notice you can do whatever you want with this stuff.
; If we meet some day, and you think this stuff is worth it, you can buy me a beer in return.

; <commercial-break>
; To view ST pictures under Windows and Linux, visit http://fail.sourceforge.net/
; </commercial-break>

; <body> ;)

; How many picture lines to read from disk at once?
; 10 is a quick compromise between performance, memory usage
; and visible progress when reading from floppy.
BUFFER_LINES	equ	10
	ert	200%BUFFER_LINES!=0
BUFFER_LEN	equ	BUFFER_LINES*160

; Addresses in VBXE memory
xdl_vbxe	equ	$10000
scr_vbxe	equ	$10100

; Zero-page variables
fx_ptr	equ	$80	; 2
st_resolution	equ	$82
y	equ	$83
scr_ptr	equ	$84	; 2
vbxe_bank	equ	$86
save_colbak	equ	$87
buf_ptr	equ	$88	; 2
bitplane	equ	$8a	; 4

	org	$8000	; we'll map VBXE memory into $4000-$7fff
main
	jsr	fx_detect
	beq	found_vbxe
	lda	<vbxe_not_found_txt
	ldx	>vbxe_not_found_txt
	jmp	print
found_vbxe

	mva	$2c8	save_colbak
	lda	<filename
	ldx	>filename
	jsr	open
	bmi	io_error
	lda	<34
	ldx	>34
	jsr	read
	bmi	io_error

	lda	buffer
	bne	format_error
	lda	buffer+1
	cmp	#2
	bcc	format_ok
format_error
	lda	<format_error_txt
	ldx	>format_error_txt
	jmp	print
format_ok
	sta	st_resolution
:4	asl	@	; 0->0, 1->XDLC_HR
	ora	>$8000	; XDLC_END
	sta	xdl_1+1

	jsr	set_palette

	mwa	#$4000+[scr_vbxe&$3fff]	scr_ptr
	mva	#$80+[scr_vbxe>>14]	vbxe_bank
	mva	#0	y
read_1
	lda	<BUFFER_LEN
	ldx	>BUFFER_LEN
	jsr	read
	bmi	io_error
	jsr	decode
	lda	y
	bne	vbxe_set_up
	jsr	setup_vbxe
	lda	#0
vbxe_set_up
	add	#BUFFER_LINES
	sta	y
; Make VBXE display as many lines as we drawn
	tax:dex
	ldy	#$5d	; MEMB
	mva	#$80+[[xdl_vbxe+xdl_2-xdl]>>14]	(fx_ptr),y	; mbce
	stx	$4000+[[xdl_vbxe+xdl_2-xdl]&$3fff]
	cpx	#199
	bcc	read_1

	jsr	close
	jsr	getchar
	jsr	reset_vbxe
	ldy	#1
	rts	; return to DOS

io_error
	jsr	reset_vbxe
	jsr	close
	lda	<io_error_txt
	ldx	>io_error_txt
	jmp	print

fx_detect
	mwa	#$d600	fx_ptr
	jsr	fx_detect_1
	beq	fx_detect_exit
	inc	fx_ptr+1
fx_detect_1
	ldy	#$40	; CORE_VERSION
	lda	(fx_ptr),y
	cmp	#$10	; FX 1.xx
	bne	fx_detect_exit
	iny	; MINOR_VERSION
	lda	(fx_ptr),y
	and	#$70
	cmp	#$20	; 1.2x
fx_detect_exit
	rts

set_palette
	ldy	#$44
	mva	#0	(fx_ptr),y+	; CSEL
	mva	#1	(fx_ptr),y	; PSEL
	ldx	#0
set_palette_1
; Each ST color is %xxxxxRRR %xGGGxBBB
	lda	st_palette,x+
	and	#7
	tay
	lda	set_palette_st2vbxe,y
	ldy	#$46	; CR
	sta	(fx_ptr),y
	lda	st_palette,x
:4	lsr	@
	and	#7
	tay
	lda	set_palette_st2vbxe,y
	ldy	#$47	; CG
	sta	(fx_ptr),y
	lda	st_palette,x+
	and	#7
	tay
	lda	set_palette_st2vbxe,y
	ldy	#$48	; CB
	sta	(fx_ptr),y
	cpx	#32
	bcc	set_palette_1
	rts

setup_vbxe
	ldy	#$5d	; MEMB
	mva	#$80+[xdl_vbxe>>14]	(fx_ptr),y	; mbce
	ldy	#xdl_len-1
	mva:rpl	xdl,y	$4000+[xdl_vbxe&$3fff],y-
	mva	#0	$22f	; disable ANTIC graphics
	sta	$2c8	; black border
	lda	20
	cmp:req	20	; wait for vblank
	ldy	#$40	; VIDEO_CONTROL
	mva	#5	(fx_ptr),y+	; no_trans|xdl_enabled
	mva	#xdl_vbxe&$ff	(fx_ptr),y+	; XDL_ADR0
	mva	#[xdl_vbxe>>8]&$ff	(fx_ptr),y+	; XDL_ADR1
	mva	#xdl_vbxe>>16	(fx_ptr),y	; XDL_ADR2
	rts

reset_vbxe
	ldy	#$5d	; MEMB
	mva	#0	(fx_ptr),y
	ldy	#$40	; VIDEO_CONTROL
	mva	#0	(fx_ptr),y
	mva	#$22	$22f	; normal screen
	mva	save_colbak	$2c8
	rts

print
	sta	$344
	stx	$345
	mva	>1024	$349	; just don't print more than 1k characters ;)
	mva	#9	$342	; write line
	ldx	#0
	jmp	$e456

getchar
; Doesn't return the char actually
	lda	<keyboard_device
	ldx	>keyboard_device
	jsr	open
	lda:tax	#0
	jsr	read
	jmp	close

open
	sta	$354
	stx	$355
	mva	#4	$35a	; open for read
	mva	#0	$35b
	lda	#3	; open
cio
	sta	$352
	ldx	#$10	; channel #1
	jmp	$e456

read
	sta	$358
	stx	$359
	mwa	#buffer	$354
	lda	#7	; read binary
	bne	cio	!

close
	lda	#12	; close
	bne	cio	!

decode
	mwa	#buffer	buf_ptr
	ldy	#$5d	; MEMB
	mva	vbxe_bank	(fx_ptr),y	; mbce
decode_1
	jsr	decode_16pixels
	add:sta	buf_ptr
	scc:inc	buf_ptr+1
	cmp	<buffer+BUFFER_LEN
	lda	buf_ptr+1
	sbc	>buffer+BUFFER_LEN
	bcc	decode_1
	rts

decode_16pixels
	lda	st_resolution
	bne	decode_medium_16pixels
decode_low_16pixels
; 16-color Atari ST mode is B0 B0 B1 B1 B2 B2 B3 B3 B0 B0 B1 B1 ...
; where B0 are bytes of the least-significant bitplane
; and B3 are bytes of the most-significant bitplane.
; For each pixel we need to get one bit from each bitplane.
	jsr	decode_low_8pixels	; B0 -- B1 -- B2 -- B3 --
	inw	buf_ptr
	jsr	decode_low_8pixels	; -- B0 -- B1 -- B2 -- B3
	lda	#7                	; advance here -----------^^
	rts

decode_low_8pixels
	ldy	#0
	mva	(buf_ptr),y	bitplane
	ldy	#2
	mva	(buf_ptr),y	bitplane+1
	ldy	#4
	mva	(buf_ptr),y	bitplane+2
	ldy	#6
	mva	(buf_ptr),y	bitplane+3
	ldx	#8
decode_low_1pixel
	lda	#0
	asl	bitplane+3
	rol	@
	asl	bitplane+2
	rol	@
	asl	bitplane+1
	rol	@
	asl	bitplane
	rol	@
	jsr	put_vbxe_byte
	dex
	bne	decode_low_1pixel
	rts

decode_medium_16pixels
; 4-color Atari ST mode is B0 B0 B1 B1 B0 B0 B1 B1 B0 ...
	jsr	decode_medium_8pixels ; B0 -- B1 --
	inw	buf_ptr
	jsr	decode_medium_8pixels ; -- B0 -- B1
	lda	#3                    ; advance here ^^
	rts

decode_medium_8pixels
	ldy	#0
	mva	(buf_ptr),y	bitplane
	ldy	#2
	mva	(buf_ptr),y	bitplane+1
	ldx	#4
decode_medium_2pixels
; for 640-pixel VBXE mode need to pack pixels in nibbles
	lda	#0
	asl	bitplane+1
	rol	@
	asl	bitplane
	rol	@
	asl:asl	@
	asl	bitplane+1
	rol	@
	asl	bitplane
	rol	@
	jsr	put_vbxe_byte
	dex
	bne	decode_medium_2pixels
	rts

put_vbxe_byte
	sta	(scr_ptr),0
	inc	scr_ptr
	bne	put_vbxe_byte_ret
	inc	scr_ptr+1
	bpl	put_vbxe_byte_ret
	lsr	scr_ptr+1
	ldy	#$5d	; MEMB
	inc:mva	vbxe_bank	(fx_ptr),y
put_vbxe_byte_ret
	rts

set_palette_st2vbxe
:8	dta	255*#/7

xdl
	dta	a($24)	; XDLC_OVOFF|XDLC_RTPL
	dta	b(19)	; 20 lines top border (VBXE screen is 240 lines)
xdl_1
	dta	a($8062) ; XDLC_GMON|XDLC_RTPL|XDLC_OVADR|XDLC_END
xdl_2
	dta	b(0)	; goes up to 199 (200 lines)
	dta	a(scr_vbxe&$ffff),b(scr_vbxe>>16),a(320)
xdl_len	equ	*-xdl

vbxe_not_found_txt
	dta	c'This program requires VBXE FX v1.2x!',$9b
io_error_txt
	dta	c'I/O error',$9b
format_error_txt
	dta	c'Invalid file - must be *.PI1 or *.PI2',$9b

keyboard_device
	dta	c'K:',$9b
filename
	dta	c'H:STPAD.PI1',$9b
;	dta	c'H:BG_PIC.PI2',$9b

buffer	org	*+BUFFER_LEN
st_palette	equ	buffer+2

	run	main
	end
